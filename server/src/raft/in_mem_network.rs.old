use tracing::{info, debug, error};
use std::sync::{Arc, Mutex};
use std::collections::HashMap;

use crate::error::ConferError;
use crate::raft::{
    config::TypeConfig,
    storage::ConferStore,
};

use openraft::OptionalSend;
use openraft::OptionalSync;
use openraft::Node;

use openraft::{
    RaftTypeConfig, Raft, RaftNetwork, NodeId,
    error::{RPCError, RaftError, InstallSnapshotError },
    network::RPCOption,
    raft::{
        AppendEntriesRequest,
        AppendEntriesResponse,
        InstallSnapshotRequest,
        InstallSnapshotResponse,
        VoteRequest,
        VoteResponse,
    }
};

// Type Alias for Raft Instance
type RaftType = Arc<Raft<TypeConfig>>;

// These aliases make the function signature easier to read
type MyNodeId = <TypeConfig as RaftTypeConfig>::NodeId;
type MyNode = <TypeConfig as RaftTypeConfig>::Node;
type MyRPCError = RPCError<MyNodeId, MyNode, ConferError>;


//type AppendEntriesError = RPCError<TypeConfig, RaftError<TypeConfig>>;
//type InstallSnapshotError = RPCError<TypeConfig, RaftError<TypeConfig, openraft::error::InstallSnapshotError>>;
//type VoteError = RPCError<TypeConfig, RaftError<TypeConfig>>;

// Custom In-Memory Network
#[derive(Default, Clone)]
pub struct ConferNetwork {
    pub nodes: Arc<Mutex<HashMap<MyNodeId, ConferNetwork>>>,
}

impl ConferNetwork {
    pub fn initialize(&mut self, node_ids: Vec<MyNodeId>) {
        let mut nodes: HashMap<MyNodeId, ConferNetwork> = HashMap::default();

        // First pass: Create empty ConferNetwork instances
        for &node_id in &node_ids {
            nodes.insert(node_id, ConferNetwork::default());
        }

        // Second pass: Populate network connections
        for &node_id in &node_ids {
            let other_node_ids: Vec<_> = node_ids.iter().filter(|&&id| id != node_id).collect();

            let network = nodes.get(&node_id).unwrap().clone();
            let mut network_nodes = network.nodes.lock().unwrap();
            network_nodes.clear(); // Use clear instead of creating a new HashMap

            for &other_node_id in &other_node_ids {
                network_nodes.insert(*other_node_id, nodes.get(&other_node_id).unwrap().clone());
            }
        }
        self.nodes = Arc::new(Mutex::new(nodes));
    }
}

#[async_trait::async_trait]
impl RaftNetwork<TypeConfig> for ConferNetwork
    where TypeConfig: OptionalSend + OptionalSync + 'static
    {
    async fn append_entries(
        &mut self,
        rpc: AppendEntriesRequest<TypeConfig>,
        option: RPCOption,
    //) -> Result<AppendEntriesResponse<MyNodeId>, AppendEntriesError> {
    ) -> Result<AppendEntriesResponse<MyNodeId>, RPCError<MyNodeId, MyNode, RaftError<MyNodeId>>>
    {
        let target_node_id = rpc.vote.leader_id();
        if let Some(target) = self.node_id_to_address.get(&target_node_id) {

            info!("Sending AppendEntriesRequest to node: {:?}", target);

            // Retrieve the target ConferNetwork instance
            if let Some(target_network) = self.nodes.get(&target) {
                // Simulate processing the request
                debug!("Node {:?} received AppendEntriesRequest", target);

                // Dummy response
                Ok(AppendEntriesResponse::Success)

            } else {
                Err(AppendEntriesError::Network(openraft::error::NetworkError::new(&format!("Node {:?} not found", target))))
            }
        }
        Err(AppendEntriesError::Network(openraft::error::NetworkError::new("Target node not specified!")))
    }

    async fn install_snapshot(
        &mut self,
        rpc: InstallSnapshotRequest<TypeConfig>,
        option: RPCOption,
    ) -> Result<InstallSnapshotResponse<MyNodeId>, RPCError<MyNodeId, MyNode, RaftError<MyNodeId, openraft::error::InstallSnapshotError>>>
    {

        let target_node_id = rpc.vote.leader_id.unwrap().node_id;
        if let Some(target) = self.node_id_to_address.get(&target_node_id) {
            info!("Sending InstallSnapshotRequest to node: {:?}", target);

            // Retrieve the target ConferNetwork instance
            if let Some(target_network) = self.nodes.get(&target) {
                // Simulate processing the request
                debug!("Node {:?} received InstallSnapshotRequest", target);

                // Dummy response
                Ok(InstallSnapshotResponse::Success);

            } else {
                Err(InstallSnapshotError::Network(openraft::error::NetworkError::new(&format!("Node {:?} not found", target))))
            }
        }
        Err(AppendEntriesError::Network(openraft::error::NetworkError::new("Target node not specified!")))
    }

    async fn vote(
        &mut self,
        rpc: VoteRequest<TypeConfig>,
        option: RPCOption,
    ) -> Result<VoteResponse<MyNodeId>, RPCError<MyNodeId, MyNode, RaftError<MyNodeId>>> {

        let target_node_id = rpc.vote.leader_id.unwrap().node_id;
        if let Some(target) = self.node_id_to_address.get(&target_node_id) {
            info!("Sending VoteRequest to node: {:?}", target);

            // Retrieve the target ConferNetwork instance
            if let Some(target_network) = self.nodes.get(&target) {
                // Simulate processing the request
                debug!("Node {:?} received VoteRequest", target);

                // Dummy response
                Ok(VoteResponse::Success)

            } else {
                Err(VoteError::Network(openraft::error::NetworkError::new(&format!("Node {:?} not found", target))))
            }
        }
        Err(AppendEntriesError::Network(openraft::error::NetworkError::new("Target node not specified!")))
    }
}
